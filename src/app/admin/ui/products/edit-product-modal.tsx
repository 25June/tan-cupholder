'use client';

import { useEffect, useState, useRef } from 'react';
import {
  updateProduct,
  State,
  fetchProductImages
} from '@/app/admin/lib/actions/products.actions';
import { ProductResponse, Product } from '@/models/product';
import {
  PhotoIcon,
  PercentBadgeIcon,
  BoltIcon
} from '@heroicons/react/24/outline';
import { getImageUrl } from '@/shared/utils/getImageUrl';
import { formatImagePath } from '@/shared/utils/formatImagePath.utils';
import { Image as ImageType } from '@/models/image';
import Image from 'next/image';
import { ProductType } from '@/models/productType';
import { onCloseModal } from '@/shared/utils/modal.utils';
import { MODAL_ID } from '@/constants/modal.const';
import { ProductTag } from '@/models/productTag';
import AutoComplete from '../autocomplete/AutoComplete';
import PrimaryColorPicker from '@/components/color-picker/PrimaryColorPicker';
import ColorDetecter from '@/components/color-detecter/ColorDetecter';
import { useGenerateProductDescription } from '@/hooks/useGenerateProductDescription';

const Form = ({
  product,
  productTypes,
  productTags,
  images,
  tagIds,
  setPrimaryColor,
  setDetectedColors,
  mainImage,
  imageId,
  formId,
  state,
  isLoading,
  thinking,
  autoGeneratedDescription,
  handleFormSubmit,
  onClose,
  setTagIds,
  onGenerateDescription
}: {
  product: Product | null;
  productTypes: ProductType[];
  productTags: ProductTag[];
  images: ImageType[];
  tagIds: string[];
  setTagIds: (value: string[]) => void;
  setPrimaryColor: (value: string) => void;
  setDetectedColors: (value: string) => void;
  mainImage?: ImageType;
  imageId?: string;
  formId: string;
  state: State;
  isLoading: boolean;
  thinking: boolean;
  autoGeneratedDescription: {
    productDescription: string;
    productAppearance: string;
    productPromise: string;
    tagline: string;
  } | null;
  handleFormSubmit: (e: React.FormEvent<HTMLFormElement>) => void;
  onClose: () => void;
  setImageId: (value: string) => void;
  onGenerateDescription: () => void;
}) => {
  if (!product)
    return (
      <div className="flex justify-center items-center p-8">
        <span className="loading loading-spinner loading-lg"></span>
      </div>
    );
  return (
    <form key={formId} onSubmit={handleFormSubmit}>
      <div className="form-control w-full max-w-full">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8 mb-2">
          <div className="flex flex-col gap-4 w-full">
            <fieldset className="fieldset">
              <legend className="fieldset-legend">Name</legend>
              <input
                type="text"
                name="name"
                className="input w-full"
                placeholder="Product Name"
                defaultValue={product.name}
              />
              <div id="name-error" aria-live="polite" aria-atomic="true">
                {state.errors?.name &&
                  state.errors.name.map((error: string) => (
                    <p className="text-sm text-red-500" key={error}>
                      {error}
                    </p>
                  ))}
              </div>
            </fieldset>

            <fieldset className="fieldset">
              <legend className="fieldset-legend">Price</legend>
              <input
                type="number"
                name="price"
                className="input w-full"
                placeholder="Product Price"
                defaultValue={product.price}
              />
              <div id="price-error" aria-live="polite" aria-atomic="true">
                {state.errors?.price &&
                  state.errors.price.map((error: string) => (
                    <p className="text-sm text-red-500" key={error}>
                      {error}
                    </p>
                  ))}
              </div>
            </fieldset>

            <fieldset className="fieldset">
              <legend className="fieldset-legend">Type</legend>
              <select
                id="type"
                name="type"
                className="peer block w-full cursor-pointer rounded-md border border-gray-200 py-2 pl-10 text-sm outline-2 placeholder:text-gray-500"
                defaultValue={product.type}
                aria-describedby="type-error"
              >
                <option value="" disabled>
                  Select type
                </option>
                {productTypes.map((productType) => (
                  <option key={productType.id} value={productType.id}>
                    {productType.name}
                  </option>
                ))}
              </select>
              <div id="type-error" aria-live="polite" aria-atomic="true">
                {state.errors?.type &&
                  state.errors.type.map((error: string) => (
                    <p className="text-sm text-red-500" key={error}>
                      {error}
                    </p>
                  ))}
              </div>
            </fieldset>

            <div className="flex gap-4 w-full">
              <fieldset className="fieldset w-full max-w-[70px]">
                <legend className="fieldset-legend">Sale</legend>
                <label className="input w-full">
                  <PercentBadgeIcon className="w-4 h-4" />
                  <input
                    type="number"
                    name="sale"
                    className="w-full"
                    placeholder="Sale Percentage"
                    defaultValue={product.sale}
                  />
                </label>

                <div id="sale-error" aria-live="polite" aria-atomic="true">
                  {state.errors?.sale ? (
                    state.errors.sale.map((error: string) => (
                      <p className="text-sm text-red-500" key={error}>
                        {error}
                      </p>
                    ))
                  ) : (
                    <p className="text-sm text-gray-500">Vd: 5, 10</p>
                  )}
                </div>
              </fieldset>
              <fieldset className="fieldset grow w-full">
                <legend className="fieldset-legend">Tag</legend>
                <AutoComplete<string>
                  options={productTags.map((tag) => ({
                    value: tag.id,
                    label: tag.name
                  }))}
                  defaultValue={tagIds}
                  onChange={(value) => {
                    setTagIds(value);
                  }}
                  placeholder="Select tags"
                />

                <div id="sale-error" aria-live="polite" aria-atomic="true">
                  {state.errors?.sale ? (
                    state.errors.sale.map((error: string) => (
                      <p className="text-sm text-red-500" key={error}>
                        {error}
                      </p>
                    ))
                  ) : (
                    <p className="text-sm text-gray-500">Vd: Hot, New, Sale</p>
                  )}
                </div>
              </fieldset>
            </div>

            <fieldset className="fieldset">
              <legend className="fieldset-legend">Stock</legend>
              <input
                type="number"
                name="stock"
                className="input w-full"
                placeholder="Stock Amount"
                defaultValue={product.stock}
              />
              <div id="stock-error" aria-live="polite" aria-atomic="true">
                {state.errors?.stock?.map((error: string) => (
                  <p className=" text-sm text-red-500" key={error}>
                    {error}
                  </p>
                ))}
              </div>
            </fieldset>

            <fieldset className="fieldset">
              <div className="flex justify-between items-center">
                <legend className="fieldset-legend">Description</legend>
                <button
                  type="button"
                  className="btn btn-soft btn-primary btn-sm btn-circle"
                  onClick={onGenerateDescription}
                >
                  {thinking ? (
                    <span className="loading loading-spinner loading-xs"></span>
                  ) : (
                    <BoltIcon className="w-4 h-4" />
                  )}
                </button>
              </div>
              {autoGeneratedDescription ? (
                <div className="flex flex-col gap-2">
                  <p className="text-sm font-bold">General Desc</p>
                  <textarea
                    name="productDescription"
                    className="textarea h-24 w-full"
                    placeholder="Product Description"
                    defaultValue={autoGeneratedDescription.productDescription}
                  />
                  <p className="text-sm font-bold">Detail Desc</p>
                  <textarea
                    name="productAppearance"
                    className="textarea h-24 w-full"
                    placeholder="Product Appearance"
                    defaultValue={autoGeneratedDescription.productAppearance}
                  />
                  <p className="text-sm font-bold">Final Desc</p>
                  <textarea
                    name="productPromise"
                    className="textarea h-24 w-full"
                    placeholder="Product Promise"
                    defaultValue={autoGeneratedDescription.productPromise}
                  />
                </div>
              ) : (
                <textarea
                  name="description"
                  className="textarea h-24 w-full"
                  placeholder="Product Description"
                  defaultValue={product.description}
                />
              )}
              <div id="description-error" aria-live="polite" aria-atomic="true">
                {state.errors?.description &&
                  state.errors.description.map((error: string) => (
                    <p className=" text-sm text-red-500" key={error}>
                      {error}
                    </p>
                  ))}
              </div>
            </fieldset>

            <fieldset className="fieldset">
              <legend className="fieldset-legend">
                Short Description
                <span className="text-xs text-gray-400 ml-2">
                  (max 255 chars)
                </span>
              </legend>
              {autoGeneratedDescription ? (
                <textarea
                  name="shortDescription"
                  className="textarea h-16 w-full"
                  placeholder="Brief summary for preview pages..."
                  defaultValue={autoGeneratedDescription.tagline || ''}
                  maxLength={255}
                />
              ) : (
                <textarea
                  name="shortDescription"
                  className="textarea h-16 w-full"
                  placeholder="Brief summary for preview pages..."
                  defaultValue={product.shortDescription || ''}
                  maxLength={255}
                />
              )}
              <div
                id="short-description-error"
                aria-live="polite"
                aria-atomic="true"
              >
                {state.errors?.shortDescription &&
                  state.errors.shortDescription.map((error: string) => (
                    <p className="text-sm text-red-500" key={error}>
                      {error}
                    </p>
                  ))}
              </div>
            </fieldset>
          </div>
          <div>
            <PrimaryColorPicker
              defaultColor={product.primaryColor || '[]'}
              onChange={setPrimaryColor}
            />

            <ColorDetecter
              imageId={imageId || ''}
              onChange={setDetectedColors}
              defaultColors={product.colors}
            />

            <fieldset className="fieldset">
              <legend className="fieldset-legend">Pattern</legend>
              <input
                type="text"
                name="pattern"
                className="input w-full"
                placeholder="e.g., Striped, Dotted, Floral"
                defaultValue={product.pattern}
              />
            </fieldset>

            <p className="text-sm font-bold mb-2 mt-4">Main Image</p>
            <div className="w-full h-full rounded-md max-h-48 mb-4">
              {mainImage ? (
                <div
                  className={`w-full h-full bg-gray-200 rounded-md max-h-48 p-2`}
                >
                  <Image
                    id="edit-image-main"
                    src={formatImagePath(
                      getImageUrl(product.id, mainImage.name)
                    )}
                    alt="Product Image"
                    className="object-contain w-full h-full"
                    width={200}
                    height={200}
                  />
                </div>
              ) : (
                <div className="w-full h-full flex flex-col items-center justify-center bg-gray-200 rounded-md max-h-48">
                  <PhotoIcon className="w-10 h-10 text-gray-500" />
                  <p className="text-sm text-gray-500">No image selected</p>
                </div>
              )}
            </div>
            <p className="text-sm font-bold mb-2">
              Other Images ({images.length})
            </p>
            <div className="grid grid-cols-2 md:grid-cols-3 gap-2 w-full">
              {(images || []).map(
                (image) =>
                  !image.isMain && (
                    <div
                      key={image.id}
                      className={`w-full h-full bg-gray-200 rounded-md max-h-56 relative p-2`}
                    >
                      <Image
                        src={formatImagePath(
                          getImageUrl(product.id, image.name)
                        )}
                        alt={image.name}
                        className="object-contain w-full h-full"
                        width={200}
                        height={200}
                      />
                    </div>
                  )
              )}
            </div>
          </div>
        </div>

        <div className="flex justify-end gap-2 mt-4">
          <button
            type="button"
            onClick={onClose}
            className="btn btn-ghost max-w-40 w-full"
          >
            Cancel
          </button>

          <button type="submit" className="btn btn-primary grow-1">
            {isLoading && <span className="loading loading-spinner"></span>}
            Update Product
          </button>
        </div>
      </div>
    </form>
  );
};

const initialState: State = { message: null, errors: {} };

interface Props {
  readonly productId: string | null;
  readonly productTypes: ProductType[];
  readonly productTags: ProductTag[];
  readonly onRefresh: (refresh?: boolean) => void;
  readonly onReset: () => void;
}

export default function EditProductModal({
  productId,
  productTypes,
  productTags,
  onRefresh,
  onReset
}: Props) {
  const [state, setState] = useState<State>(initialState);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [product, setProduct] = useState<Product | null>(null);
  const [images, setImages] = useState<ImageType[]>([]);
  const [tagIds, setTagIds] = useState<string[]>([]);
  const [formId, setFormId] = useState<string>('');
  const modalRef = useRef<HTMLDialogElement | null>(null);
  const [primaryColor, setPrimaryColor] = useState<string>(''); // JSON array of color hex values
  const [detectedColors, setDetectedColors] = useState<string>(''); // JSON array of color hex values
  const [imageId, setImageId] = useState<string>();

  const { generateDescription, thinking, description } =
    useGenerateProductDescription();

  const handleGenerateDescription = async () => {
    if (!product) return;
    console.log({
      name: product.name,
      productTypeName: product.type,
      productTypeDescription: product.type,
      colors: product.colors,
      pattern: product.pattern
    });
    const productType = productTypes.find((type) => type.id === product.type);

    const formData = new FormData();
    formData.append('name', product.name);
    formData.append('productTypeName', productType?.name || '');
    formData.append('productTypeDescription', productType?.description || '');
    formData.append('pattern', product.pattern || '');
    formData.append('colors', product.colors || '[]');

    const result = await generateDescription(formData);
    console.log(result);
  };

  useEffect(() => {
    const onFetchProductById = async () => {
      const modal = modalRef.current;
      if (!modal) return;

      const idToLoad = productId;
      if (!idToLoad) return;

      try {
        // Try to get product data from data attribute first
        const productDataStr = modal.getAttribute('data-product');
        if (productDataStr) {
          try {
            const productData: ProductResponse = JSON.parse(productDataStr);
            // Convert ProductResponse to Product format
            setProduct({
              id: productData.id,
              name: productData.name,
              description: productData.description,
              shortDescription: productData.shortDescription,
              price: productData.price,
              sale: productData.sale,
              stock: productData.stock,
              type: productData.type,
              tagIds: productData.tagIds,
              primaryColor: productData.primaryColor,
              colors: productData.colors,
              pattern: productData.pattern
            });
            setTagIds(productData.tagIds || []);
            setPrimaryColor(productData.primaryColor || '[]');
            setDetectedColors(productData.colors || '');
          } catch (e) {
            console.error('Failed to parse product data:', e);
            // Fallback: if parsing fails, we'd need to fetch, but this shouldn't happen
          }
        }

        // Still need to fetch images (only images, not the full product)
        const imagesData = await fetchProductImages(idToLoad);
        setImages(imagesData || []);

        // Set imageId for ColorDetecter after images are loaded
        if (imagesData && imagesData.length > 0) {
          setTimeout(() => {
            setImageId(`edit-image-main`);
          }, 1000);
        }
      } catch (error) {
        console.error('Failed to load product data:', error);
      }
    };
    if (productId) {
      onFetchProductById();
    }
  }, [productId]);

  const mainImage = images.find((image) => image.isMain);

  const getDescription = ({
    originalDescription,
    productDescription,
    productAppearance,
    productPromise
  }: {
    originalDescription: string;
    productDescription: string;
    productAppearance: string;
    productPromise: string;
  }) => {
    if (description) {
      return JSON.stringify({
        productDescription: productDescription || '',
        productAppearance: productAppearance || '',
        productPromise: productPromise || ''
      });
    }
    return originalDescription;
  };

  const handleFormSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (!product) return;

    const formData = new FormData(e.currentTarget);
    formData.set('id', product.id);
    formData.set('tagIds', tagIds.join(',') || '');
    formData.set('primaryColor', primaryColor);
    formData.set('colors', detectedColors);
    formData.set(
      'description',
      getDescription({
        originalDescription: product.description,
        productDescription: formData.get('productDescription') as string,
        productAppearance: formData.get('productAppearance') as string,
        productPromise: formData.get('productPromise') as string
      })
    );
    formData.set(
      'shortDescription',
      formData.get('shortDescription') as string
    );
    setIsLoading(true);
    return updateProduct(initialState, formData)
      .then((res: any) => {
        if (res.errors) {
          setState({
            message: res.message,
            errors: res.errors
          });
          setIsLoading(false);
          return;
        }
        setState(initialState);
        handleClose(true);
      })
      .catch((error) => {
        setState({
          message: error.message,
          errors: error.errors
        });
      })
      .finally(() => {
        setIsLoading(false);
      });
  };

  const handleClose = (refresh?: boolean) => {
    onCloseModal(MODAL_ID.UPDATE_PRODUCT);
    setState(initialState);
    setProduct(null);
    setImages([]);
    setFormId(Date.now().toString());
    setPrimaryColor('');
    setDetectedColors('');
    setImageId(undefined);
    onReset();
    const modal = modalRef.current;
    if (modal) {
      modal.removeAttribute('data-product');
    }
    console.log('refresh', refresh);
    onRefresh(refresh);
  };

  return (
    <dialog id={MODAL_ID.UPDATE_PRODUCT} className="modal" ref={modalRef}>
      <div className="modal-box max-w-4xl">
        <h3 className="font-bold text-lg mb-4">Edit Product</h3>
        <Form
          product={product}
          productTypes={productTypes}
          productTags={productTags}
          images={images}
          tagIds={tagIds}
          setPrimaryColor={setPrimaryColor}
          setDetectedColors={setDetectedColors}
          mainImage={mainImage}
          imageId={imageId}
          setImageId={setImageId}
          setTagIds={setTagIds}
          formId={formId}
          state={state}
          isLoading={isLoading}
          thinking={thinking}
          handleFormSubmit={handleFormSubmit}
          onClose={() => handleClose(false)}
          onGenerateDescription={handleGenerateDescription}
          autoGeneratedDescription={description}
        />
      </div>
      <form method="dialog" className="modal-backdrop">
        <button
          onClick={() => {
            handleClose(false);
          }}
        >
          close
        </button>
      </form>
    </dialog>
  );
}
